defpackage curl/opt :
   import core

; This is the FILE * or void * the regular output should be written to.
protected val WRITEDATA = 1001

; The full URL to get/put
protected val URL = 1002

; Port number to connect to, if other than default.
protected val PORT = 3

; Name of proxy to use.
protected val PROXY = 1004

; "user:password;options" to use when fetching.
protected val USERPWD = 1005

; "user:password" to use with proxy.
protected val PROXYUSERPWD = 1006

; Range to get, specified as an ASCII string.
protected val RANGE = 1007

; Specified file stream to upload from (use as input):
protected val READDATA = 1009

; Buffer to receive error messages in, must be at least CURL_ERROR_SIZE
; bytes big. If this is not used, error messages go to stderr instead:
protected val ERRORBUFFER = 1010

; Function that will be called to store the output (instead of fwrite). The
; parameters will use fwrite() syntax, make sure to follow them.
protected val WRITEFUNCTION = 2011

; Function that will be called to read the input (instead of fread). The
; parameters will use fread() syntax, make sure to follow them.
protected val READFUNCTION = 2012

; Time-out the read operation after this amount of seconds
protected val TIMEOUT = 13

; If the CURLOPT_INFILE is used, this can be used to inform libcurl about
; how large the file being sent really is. That allows better error
; checking and better verifies that the upload was successful. -1 means
; unknown size.
;
; For large file support, there is also a _LARGE version of the key
; which takes an off_t type, allowing platforms with larger off_t
; sizes to handle larger files.  See below for INFILESIZE_LARGE.
protected val INFILSIZE = 14

; POST static input fields.
protected val POSTFIELDS = 1015

; Set the referrer page (needed by some CGIs)
protected val REFERER = 1016

; Set the FTP PORT string (interface name, named or numerical IP address)
; Use i.e '-' to use default address.
protected val FTPPORT = 1017

; Set the User-Agent string (examined by some CGIs)
protected val USERAGENT = 1018

; If the download receives less than "low speed limit" bytes/second
; during "low speed time" seconds, the operations is aborted.
; You could i.e if you have a pretty high speed connection, abort if
; it is less than 2000 bytes/sec during 20 seconds.

; Set the "low speed limit"
protected val LOW_SPEED_LIMIT = 19

; Set the "low speed time"
protected val LOW_SPEED_TIME = 20

; Set the continuation offset.
;
; Note there is also a _LARGE version of this key which uses
; off_t types, allowing for large file offsets on platforms which
; use larger-than-32-bit off_t's.  Look below for RESUME_FROM_LARGE.
protected val RESUME_FROM = 21

; Set cookie in request:
protected val COOKIE = 1022

; GLOBAL OPTIONS

protected lostanza val SSL:long = 1 << 0
protected lostanza val WIN32:long = 1 << 1
protected lostanza val ALL:long = SSL|WIN32
protected lostanza val NOTHING:long = 0
protected lostanza val DEFAULT:long = ALL
protected lostanza val ACK_EINTR:long = 1 << 2
